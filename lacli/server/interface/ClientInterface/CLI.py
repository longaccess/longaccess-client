#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted,new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(Interface):
  def PingCLI():
    pass

  def CloseWhenPossible():
    pass

  def LoginUser(username, Pass, Remember):
    """
    Parameters:
     - username
     - Pass
     - Remember
    """
    pass

  def UserIsLoggedIn():
    pass

  def Logout():
    pass

  def GetCapsules():
    pass

  def CreateArchive(filePaths):
    """
    Parameters:
     - filePaths
    """
    pass

  def GetUploads():
    pass

  def UploadToCapsule(ArchiveLocalID, CapsuleID, title, description):
    """
    Parameters:
     - ArchiveLocalID
     - CapsuleID
     - title
     - description
    """
    pass

  def ResumeUpload(ArchiveLocalID):
    """
    Parameters:
     - ArchiveLocalID
    """
    pass

  def QueryArchiveStatus(ArchiveLocalID):
    """
    Parameters:
     - ArchiveLocalID
    """
    pass

  def PauseUpload(ArchiveLocalID):
    """
    Parameters:
     - ArchiveLocalID
    """
    pass

  def CancelUpload(ArchiveLocalID):
    """
    Parameters:
     - ArchiveLocalID
    """
    pass

  def GetCertificates():
    pass

  def ExportCertificate(ArchiveID, format):
    """
    Parameters:
     - ArchiveID
     - format
    """
    pass

  def Decrypt(archivePath, key, destinationPath):
    """
    Parameters:
     - archivePath
     - key
     - destinationPath
    """
    pass

  def GetSettings():
    pass

  def SetSettings(settings):
    """
    Parameters:
     - settings
    """
    pass


class Client(object):
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    self._transport = transport
    self._oprot_factory = oprot_factory
    self._seqid = 0
    self._reqs = {}

  def PingCLI(self, ):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_PingCLI()
    return d

  def send_PingCLI(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('PingCLI', TMessageType.CALL, self._seqid)
    args = PingCLI_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_PingCLI(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = PingCLI_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "PingCLI failed: unknown result"))

  def CloseWhenPossible(self, ):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_CloseWhenPossible()
    return d

  def send_CloseWhenPossible(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('CloseWhenPossible', TMessageType.CALL, self._seqid)
    args = CloseWhenPossible_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_CloseWhenPossible(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = CloseWhenPossible_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def LoginUser(self, username, Pass, Remember):
    """
    Parameters:
     - username
     - Pass
     - Remember
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_LoginUser(username, Pass, Remember)
    return d

  def send_LoginUser(self, username, Pass, Remember):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('LoginUser', TMessageType.CALL, self._seqid)
    args = LoginUser_args()
    args.username = username
    args.Pass = Pass
    args.Remember = Remember
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_LoginUser(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = LoginUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "LoginUser failed: unknown result"))

  def UserIsLoggedIn(self, ):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_UserIsLoggedIn()
    return d

  def send_UserIsLoggedIn(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('UserIsLoggedIn', TMessageType.CALL, self._seqid)
    args = UserIsLoggedIn_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_UserIsLoggedIn(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = UserIsLoggedIn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "UserIsLoggedIn failed: unknown result"))

  def Logout(self, ):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_Logout()
    return d

  def send_Logout(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('Logout', TMessageType.CALL, self._seqid)
    args = Logout_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_Logout(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = Logout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "Logout failed: unknown result"))

  def GetCapsules(self, ):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_GetCapsules()
    return d

  def send_GetCapsules(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('GetCapsules', TMessageType.CALL, self._seqid)
    args = GetCapsules_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_GetCapsules(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = GetCapsules_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "GetCapsules failed: unknown result"))

  def CreateArchive(self, filePaths):
    """
    Parameters:
     - filePaths
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_CreateArchive(filePaths)
    return d

  def send_CreateArchive(self, filePaths):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('CreateArchive', TMessageType.CALL, self._seqid)
    args = CreateArchive_args()
    args.filePaths = filePaths
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_CreateArchive(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = CreateArchive_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "CreateArchive failed: unknown result"))

  def GetUploads(self, ):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_GetUploads()
    return d

  def send_GetUploads(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('GetUploads', TMessageType.CALL, self._seqid)
    args = GetUploads_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_GetUploads(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = GetUploads_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "GetUploads failed: unknown result"))

  def UploadToCapsule(self, ArchiveLocalID, CapsuleID, title, description):
    """
    Parameters:
     - ArchiveLocalID
     - CapsuleID
     - title
     - description
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_UploadToCapsule(ArchiveLocalID, CapsuleID, title, description)
    return d

  def send_UploadToCapsule(self, ArchiveLocalID, CapsuleID, title, description):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('UploadToCapsule', TMessageType.CALL, self._seqid)
    args = UploadToCapsule_args()
    args.ArchiveLocalID = ArchiveLocalID
    args.CapsuleID = CapsuleID
    args.title = title
    args.description = description
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_UploadToCapsule(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = UploadToCapsule_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      return d.errback(result.error)
    return d.callback(None)

  def ResumeUpload(self, ArchiveLocalID):
    """
    Parameters:
     - ArchiveLocalID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_ResumeUpload(ArchiveLocalID)
    return d

  def send_ResumeUpload(self, ArchiveLocalID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('ResumeUpload', TMessageType.CALL, self._seqid)
    args = ResumeUpload_args()
    args.ArchiveLocalID = ArchiveLocalID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_ResumeUpload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = ResumeUpload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      return d.errback(result.error)
    return d.callback(None)

  def QueryArchiveStatus(self, ArchiveLocalID):
    """
    Parameters:
     - ArchiveLocalID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_QueryArchiveStatus(ArchiveLocalID)
    return d

  def send_QueryArchiveStatus(self, ArchiveLocalID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('QueryArchiveStatus', TMessageType.CALL, self._seqid)
    args = QueryArchiveStatus_args()
    args.ArchiveLocalID = ArchiveLocalID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_QueryArchiveStatus(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = QueryArchiveStatus_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "QueryArchiveStatus failed: unknown result"))

  def PauseUpload(self, ArchiveLocalID):
    """
    Parameters:
     - ArchiveLocalID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_PauseUpload(ArchiveLocalID)
    return d

  def send_PauseUpload(self, ArchiveLocalID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('PauseUpload', TMessageType.CALL, self._seqid)
    args = PauseUpload_args()
    args.ArchiveLocalID = ArchiveLocalID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_PauseUpload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = PauseUpload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      return d.errback(result.error)
    return d.callback(None)

  def CancelUpload(self, ArchiveLocalID):
    """
    Parameters:
     - ArchiveLocalID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_CancelUpload(ArchiveLocalID)
    return d

  def send_CancelUpload(self, ArchiveLocalID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('CancelUpload', TMessageType.CALL, self._seqid)
    args = CancelUpload_args()
    args.ArchiveLocalID = ArchiveLocalID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_CancelUpload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = CancelUpload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      return d.errback(result.error)
    return d.callback(None)

  def GetCertificates(self, ):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_GetCertificates()
    return d

  def send_GetCertificates(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('GetCertificates', TMessageType.CALL, self._seqid)
    args = GetCertificates_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_GetCertificates(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = GetCertificates_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "GetCertificates failed: unknown result"))

  def ExportCertificate(self, ArchiveID, format):
    """
    Parameters:
     - ArchiveID
     - format
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_ExportCertificate(ArchiveID, format)
    return d

  def send_ExportCertificate(self, ArchiveID, format):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('ExportCertificate', TMessageType.CALL, self._seqid)
    args = ExportCertificate_args()
    args.ArchiveID = ArchiveID
    args.format = format
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_ExportCertificate(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = ExportCertificate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "ExportCertificate failed: unknown result"))

  def Decrypt(self, archivePath, key, destinationPath):
    """
    Parameters:
     - archivePath
     - key
     - destinationPath
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_Decrypt(archivePath, key, destinationPath)
    return d

  def send_Decrypt(self, archivePath, key, destinationPath):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('Decrypt', TMessageType.CALL, self._seqid)
    args = Decrypt_args()
    args.archivePath = archivePath
    args.key = key
    args.destinationPath = destinationPath
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_Decrypt(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = Decrypt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      return d.errback(result.error)
    return d.callback(None)

  def GetSettings(self, ):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_GetSettings()
    return d

  def send_GetSettings(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('GetSettings', TMessageType.CALL, self._seqid)
    args = GetSettings_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_GetSettings(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = GetSettings_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "GetSettings failed: unknown result"))

  def SetSettings(self, settings):
    """
    Parameters:
     - settings
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_SetSettings(settings)
    return d

  def send_SetSettings(self, settings):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('SetSettings', TMessageType.CALL, self._seqid)
    args = SetSettings_args()
    args.settings = settings
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_SetSettings(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = SetSettings_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)


class Processor(TProcessor):
  implements(Iface)

  def __init__(self, handler):
    self._handler = Iface(handler)
    self._processMap = {}
    self._processMap["PingCLI"] = Processor.process_PingCLI
    self._processMap["CloseWhenPossible"] = Processor.process_CloseWhenPossible
    self._processMap["LoginUser"] = Processor.process_LoginUser
    self._processMap["UserIsLoggedIn"] = Processor.process_UserIsLoggedIn
    self._processMap["Logout"] = Processor.process_Logout
    self._processMap["GetCapsules"] = Processor.process_GetCapsules
    self._processMap["CreateArchive"] = Processor.process_CreateArchive
    self._processMap["GetUploads"] = Processor.process_GetUploads
    self._processMap["UploadToCapsule"] = Processor.process_UploadToCapsule
    self._processMap["ResumeUpload"] = Processor.process_ResumeUpload
    self._processMap["QueryArchiveStatus"] = Processor.process_QueryArchiveStatus
    self._processMap["PauseUpload"] = Processor.process_PauseUpload
    self._processMap["CancelUpload"] = Processor.process_CancelUpload
    self._processMap["GetCertificates"] = Processor.process_GetCertificates
    self._processMap["ExportCertificate"] = Processor.process_ExportCertificate
    self._processMap["Decrypt"] = Processor.process_Decrypt
    self._processMap["GetSettings"] = Processor.process_GetSettings
    self._processMap["SetSettings"] = Processor.process_SetSettings

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_PingCLI(self, seqid, iprot, oprot):
    args = PingCLI_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PingCLI_result()
    d = defer.maybeDeferred(self._handler.PingCLI, )
    d.addCallback(self.write_results_success_PingCLI, result, seqid, oprot)
    return d

  def write_results_success_PingCLI(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("PingCLI", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CloseWhenPossible(self, seqid, iprot, oprot):
    args = CloseWhenPossible_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CloseWhenPossible_result()
    d = defer.maybeDeferred(self._handler.CloseWhenPossible, )
    d.addCallback(self.write_results_success_CloseWhenPossible, result, seqid, oprot)
    return d

  def write_results_success_CloseWhenPossible(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("CloseWhenPossible", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LoginUser(self, seqid, iprot, oprot):
    args = LoginUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LoginUser_result()
    d = defer.maybeDeferred(self._handler.LoginUser, args.username, args.Pass, args.Remember)
    d.addCallback(self.write_results_success_LoginUser, result, seqid, oprot)
    d.addErrback(self.write_results_exception_LoginUser, result, seqid, oprot)
    return d

  def write_results_success_LoginUser(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("LoginUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_LoginUser(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("LoginUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_UserIsLoggedIn(self, seqid, iprot, oprot):
    args = UserIsLoggedIn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = UserIsLoggedIn_result()
    d = defer.maybeDeferred(self._handler.UserIsLoggedIn, )
    d.addCallback(self.write_results_success_UserIsLoggedIn, result, seqid, oprot)
    return d

  def write_results_success_UserIsLoggedIn(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("UserIsLoggedIn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_Logout(self, seqid, iprot, oprot):
    args = Logout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Logout_result()
    d = defer.maybeDeferred(self._handler.Logout, )
    d.addCallback(self.write_results_success_Logout, result, seqid, oprot)
    d.addErrback(self.write_results_exception_Logout, result, seqid, oprot)
    return d

  def write_results_success_Logout(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("Logout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_Logout(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("Logout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCapsules(self, seqid, iprot, oprot):
    args = GetCapsules_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCapsules_result()
    d = defer.maybeDeferred(self._handler.GetCapsules, )
    d.addCallback(self.write_results_success_GetCapsules, result, seqid, oprot)
    d.addErrback(self.write_results_exception_GetCapsules, result, seqid, oprot)
    return d

  def write_results_success_GetCapsules(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("GetCapsules", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_GetCapsules(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("GetCapsules", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CreateArchive(self, seqid, iprot, oprot):
    args = CreateArchive_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CreateArchive_result()
    d = defer.maybeDeferred(self._handler.CreateArchive, args.filePaths)
    d.addCallback(self.write_results_success_CreateArchive, result, seqid, oprot)
    d.addErrback(self.write_results_exception_CreateArchive, result, seqid, oprot)
    return d

  def write_results_success_CreateArchive(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("CreateArchive", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_CreateArchive(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("CreateArchive", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetUploads(self, seqid, iprot, oprot):
    args = GetUploads_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetUploads_result()
    d = defer.maybeDeferred(self._handler.GetUploads, )
    d.addCallback(self.write_results_success_GetUploads, result, seqid, oprot)
    return d

  def write_results_success_GetUploads(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("GetUploads", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_UploadToCapsule(self, seqid, iprot, oprot):
    args = UploadToCapsule_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = UploadToCapsule_result()
    d = defer.maybeDeferred(self._handler.UploadToCapsule, args.ArchiveLocalID, args.CapsuleID, args.title, args.description)
    d.addCallback(self.write_results_success_UploadToCapsule, result, seqid, oprot)
    d.addErrback(self.write_results_exception_UploadToCapsule, result, seqid, oprot)
    return d

  def write_results_success_UploadToCapsule(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("UploadToCapsule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_UploadToCapsule(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("UploadToCapsule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ResumeUpload(self, seqid, iprot, oprot):
    args = ResumeUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ResumeUpload_result()
    d = defer.maybeDeferred(self._handler.ResumeUpload, args.ArchiveLocalID)
    d.addCallback(self.write_results_success_ResumeUpload, result, seqid, oprot)
    d.addErrback(self.write_results_exception_ResumeUpload, result, seqid, oprot)
    return d

  def write_results_success_ResumeUpload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("ResumeUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_ResumeUpload(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("ResumeUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_QueryArchiveStatus(self, seqid, iprot, oprot):
    args = QueryArchiveStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = QueryArchiveStatus_result()
    d = defer.maybeDeferred(self._handler.QueryArchiveStatus, args.ArchiveLocalID)
    d.addCallback(self.write_results_success_QueryArchiveStatus, result, seqid, oprot)
    d.addErrback(self.write_results_exception_QueryArchiveStatus, result, seqid, oprot)
    return d

  def write_results_success_QueryArchiveStatus(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("QueryArchiveStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_QueryArchiveStatus(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("QueryArchiveStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_PauseUpload(self, seqid, iprot, oprot):
    args = PauseUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PauseUpload_result()
    d = defer.maybeDeferred(self._handler.PauseUpload, args.ArchiveLocalID)
    d.addCallback(self.write_results_success_PauseUpload, result, seqid, oprot)
    d.addErrback(self.write_results_exception_PauseUpload, result, seqid, oprot)
    return d

  def write_results_success_PauseUpload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("PauseUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_PauseUpload(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("PauseUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CancelUpload(self, seqid, iprot, oprot):
    args = CancelUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CancelUpload_result()
    d = defer.maybeDeferred(self._handler.CancelUpload, args.ArchiveLocalID)
    d.addCallback(self.write_results_success_CancelUpload, result, seqid, oprot)
    d.addErrback(self.write_results_exception_CancelUpload, result, seqid, oprot)
    return d

  def write_results_success_CancelUpload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("CancelUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_CancelUpload(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("CancelUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCertificates(self, seqid, iprot, oprot):
    args = GetCertificates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCertificates_result()
    d = defer.maybeDeferred(self._handler.GetCertificates, )
    d.addCallback(self.write_results_success_GetCertificates, result, seqid, oprot)
    return d

  def write_results_success_GetCertificates(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("GetCertificates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ExportCertificate(self, seqid, iprot, oprot):
    args = ExportCertificate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ExportCertificate_result()
    d = defer.maybeDeferred(self._handler.ExportCertificate, args.ArchiveID, args.format)
    d.addCallback(self.write_results_success_ExportCertificate, result, seqid, oprot)
    d.addErrback(self.write_results_exception_ExportCertificate, result, seqid, oprot)
    return d

  def write_results_success_ExportCertificate(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("ExportCertificate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_ExportCertificate(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("ExportCertificate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_Decrypt(self, seqid, iprot, oprot):
    args = Decrypt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Decrypt_result()
    d = defer.maybeDeferred(self._handler.Decrypt, args.archivePath, args.key, args.destinationPath)
    d.addCallback(self.write_results_success_Decrypt, result, seqid, oprot)
    d.addErrback(self.write_results_exception_Decrypt, result, seqid, oprot)
    return d

  def write_results_success_Decrypt(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("Decrypt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_Decrypt(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation as error:
      result.error = error
    oprot.writeMessageBegin("Decrypt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetSettings(self, seqid, iprot, oprot):
    args = GetSettings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetSettings_result()
    d = defer.maybeDeferred(self._handler.GetSettings, )
    d.addCallback(self.write_results_success_GetSettings, result, seqid, oprot)
    return d

  def write_results_success_GetSettings(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("GetSettings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetSettings(self, seqid, iprot, oprot):
    args = SetSettings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetSettings_result()
    d = defer.maybeDeferred(self._handler.SetSettings, args.settings)
    d.addCallback(self.write_results_success_SetSettings, result, seqid, oprot)
    return d

  def write_results_success_SetSettings(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("SetSettings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class PingCLI_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PingCLI_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PingCLI_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PingCLI_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CloseWhenPossible_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CloseWhenPossible_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CloseWhenPossible_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CloseWhenPossible_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LoginUser_args(object):
  """
  Attributes:
   - username
   - Pass
   - Remember
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
    (2, TType.STRING, 'Pass', None, None, ), # 2
    (3, TType.BOOL, 'Remember', None, None, ), # 3
  )

  def __init__(self, username=None, Pass=None, Remember=None,):
    self.username = username
    self.Pass = Pass
    self.Remember = Remember

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.Pass = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.Remember = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LoginUser_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.Pass is not None:
      oprot.writeFieldBegin('Pass', TType.STRING, 2)
      oprot.writeString(self.Pass)
      oprot.writeFieldEnd()
    if self.Remember is not None:
      oprot.writeFieldBegin('Remember', TType.BOOL, 3)
      oprot.writeBool(self.Remember)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LoginUser_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LoginUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserIsLoggedIn_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserIsLoggedIn_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserIsLoggedIn_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserIsLoggedIn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Logout_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Logout_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Logout_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Logout_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCapsules_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCapsules_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCapsules_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Capsule, Capsule.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = Capsule()
            _elem12.read(iprot)
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCapsules_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter13 in self.success:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateArchive_args(object):
  """
  Attributes:
   - filePaths
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'filePaths', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, filePaths=None,):
    self.filePaths = filePaths

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.filePaths = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.filePaths.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateArchive_args')
    if self.filePaths is not None:
      oprot.writeFieldBegin('filePaths', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.filePaths))
      for iter20 in self.filePaths:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateArchive_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Archive, Archive.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Archive()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateArchive_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetUploads_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetUploads_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetUploads_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Archive, Archive.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = Archive()
            _elem26.read(iprot)
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetUploads_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter27 in self.success:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UploadToCapsule_args(object):
  """
  Attributes:
   - ArchiveLocalID
   - CapsuleID
   - title
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveLocalID', None, None, ), # 1
    (2, TType.STRING, 'CapsuleID', None, None, ), # 2
    (3, TType.STRING, 'title', None, None, ), # 3
    (4, TType.STRING, 'description', None, None, ), # 4
  )

  def __init__(self, ArchiveLocalID=None, CapsuleID=None, title=None, description=None,):
    self.ArchiveLocalID = ArchiveLocalID
    self.CapsuleID = CapsuleID
    self.title = title
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveLocalID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.CapsuleID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UploadToCapsule_args')
    if self.ArchiveLocalID is not None:
      oprot.writeFieldBegin('ArchiveLocalID', TType.STRING, 1)
      oprot.writeString(self.ArchiveLocalID)
      oprot.writeFieldEnd()
    if self.CapsuleID is not None:
      oprot.writeFieldBegin('CapsuleID', TType.STRING, 2)
      oprot.writeString(self.CapsuleID)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 3)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 4)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UploadToCapsule_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UploadToCapsule_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResumeUpload_args(object):
  """
  Attributes:
   - ArchiveLocalID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveLocalID', None, None, ), # 1
  )

  def __init__(self, ArchiveLocalID=None,):
    self.ArchiveLocalID = ArchiveLocalID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveLocalID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResumeUpload_args')
    if self.ArchiveLocalID is not None:
      oprot.writeFieldBegin('ArchiveLocalID', TType.STRING, 1)
      oprot.writeString(self.ArchiveLocalID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResumeUpload_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResumeUpload_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryArchiveStatus_args(object):
  """
  Attributes:
   - ArchiveLocalID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveLocalID', None, None, ), # 1
  )

  def __init__(self, ArchiveLocalID=None,):
    self.ArchiveLocalID = ArchiveLocalID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveLocalID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryArchiveStatus_args')
    if self.ArchiveLocalID is not None:
      oprot.writeFieldBegin('ArchiveLocalID', TType.STRING, 1)
      oprot.writeString(self.ArchiveLocalID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryArchiveStatus_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TransferStatus, TransferStatus.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TransferStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryArchiveStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PauseUpload_args(object):
  """
  Attributes:
   - ArchiveLocalID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveLocalID', None, None, ), # 1
  )

  def __init__(self, ArchiveLocalID=None,):
    self.ArchiveLocalID = ArchiveLocalID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveLocalID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PauseUpload_args')
    if self.ArchiveLocalID is not None:
      oprot.writeFieldBegin('ArchiveLocalID', TType.STRING, 1)
      oprot.writeString(self.ArchiveLocalID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PauseUpload_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PauseUpload_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CancelUpload_args(object):
  """
  Attributes:
   - ArchiveLocalID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveLocalID', None, None, ), # 1
  )

  def __init__(self, ArchiveLocalID=None,):
    self.ArchiveLocalID = ArchiveLocalID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveLocalID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CancelUpload_args')
    if self.ArchiveLocalID is not None:
      oprot.writeFieldBegin('ArchiveLocalID', TType.STRING, 1)
      oprot.writeString(self.ArchiveLocalID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CancelUpload_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CancelUpload_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCertificates_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCertificates_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCertificates_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Certificate, Certificate.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = Certificate()
            _elem33.read(iprot)
            self.success.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCertificates_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter34 in self.success:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExportCertificate_args(object):
  """
  Attributes:
   - ArchiveID
   - format
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveID', None, None, ), # 1
    (2, TType.I32, 'format', None, None, ), # 2
  )

  def __init__(self, ArchiveID=None, format=None,):
    self.ArchiveID = ArchiveID
    self.format = format

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.format = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExportCertificate_args')
    if self.ArchiveID is not None:
      oprot.writeFieldBegin('ArchiveID', TType.STRING, 1)
      oprot.writeString(self.ArchiveID)
      oprot.writeFieldEnd()
    if self.format is not None:
      oprot.writeFieldBegin('format', TType.I32, 2)
      oprot.writeI32(self.format)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExportCertificate_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExportCertificate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Decrypt_args(object):
  """
  Attributes:
   - archivePath
   - key
   - destinationPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'archivePath', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'destinationPath', None, None, ), # 3
  )

  def __init__(self, archivePath=None, key=None, destinationPath=None,):
    self.archivePath = archivePath
    self.key = key
    self.destinationPath = destinationPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.archivePath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.destinationPath = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Decrypt_args')
    if self.archivePath is not None:
      oprot.writeFieldBegin('archivePath', TType.STRING, 1)
      oprot.writeString(self.archivePath)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.destinationPath is not None:
      oprot.writeFieldBegin('destinationPath', TType.STRING, 3)
      oprot.writeString(self.destinationPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Decrypt_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Decrypt_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSettings_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSettings_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetSettings_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Settings, Settings.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Settings()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetSettings_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSettings_args(object):
  """
  Attributes:
   - settings
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'settings', (Settings, Settings.thrift_spec), None, ), # 1
  )

  def __init__(self, settings=None,):
    self.settings = settings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.settings = Settings()
          self.settings.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSettings_args')
    if self.settings is not None:
      oprot.writeFieldBegin('settings', TType.STRUCT, 1)
      self.settings.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetSettings_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetSettings_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
