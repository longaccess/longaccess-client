#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted,new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(Interface):
  def PingCLI():
    pass

  def LoginUser(username, Pass, Remember):
    """
    Parameters:
     - username
     - Pass
     - Remember
    """
    pass

  def Logout():
    pass

  def GetCapsules():
    pass

  def UploadFileGUI(filePaths, capsuleID, title, description):
    """
    Parameters:
     - filePaths
     - capsuleID
     - title
     - description
    """
    pass

  def GetIncompleteUploads():
    pass

  def BeginUpload(ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    pass

  def ResumeUpload(ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    pass

  def QueryArchiveStatus(ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    pass

  def PauseUpload(ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    pass

  def CancelUpload(ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    pass

  def getCertificates():
    pass

  def GetCertificateFolder():
    pass

  def SetCertificateFolder(path):
    """
    Parameters:
     - path
    """
    pass

  def Export(certificateID, format):
    """
    Parameters:
     - certificateID
     - format
    """
    pass

  def Decrypt(archivePath, key, destinationPath):
    """
    Parameters:
     - archivePath
     - key
     - destinationPath
    """
    pass


class Client(object):
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    self._transport = transport
    self._oprot_factory = oprot_factory
    self._seqid = 0
    self._reqs = {}

  def PingCLI(self):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_PingCLI()
    return d

  def send_PingCLI(self):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('PingCLI', TMessageType.CALL, self._seqid)
    args = PingCLI_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_PingCLI(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = PingCLI_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def LoginUser(self, username, Pass, Remember):
    """
    Parameters:
     - username
     - Pass
     - Remember
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_LoginUser(username, Pass, Remember)
    return d

  def send_LoginUser(self, username, Pass, Remember):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('LoginUser', TMessageType.CALL, self._seqid)
    args = LoginUser_args()
    args.username = username
    args.Pass = Pass
    args.Remember = Remember
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_LoginUser(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = LoginUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "LoginUser failed: unknown result"))

  def Logout(self):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_Logout()
    return d

  def send_Logout(self):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('Logout', TMessageType.CALL, self._seqid)
    args = Logout_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_Logout(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = Logout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "Logout failed: unknown result"))

  def GetCapsules(self):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_GetCapsules()
    return d

  def send_GetCapsules(self):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('GetCapsules', TMessageType.CALL, self._seqid)
    args = GetCapsules_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_GetCapsules(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = GetCapsules_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "GetCapsules failed: unknown result"))

  def UploadFileGUI(self, filePaths, capsuleID, title, description):
    """
    Parameters:
     - filePaths
     - capsuleID
     - title
     - description
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_UploadFileGUI(filePaths, capsuleID, title, description)
    return d

  def send_UploadFileGUI(self, filePaths, capsuleID, title, description):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('UploadFileGUI', TMessageType.CALL, self._seqid)
    args = UploadFileGUI_args()
    args.filePaths = filePaths
    args.capsuleID = capsuleID
    args.title = title
    args.description = description
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_UploadFileGUI(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = UploadFileGUI_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.error is not None:
      return d.errback(result.error)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "UploadFileGUI failed: unknown result"))

  def GetIncompleteUploads(self):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_GetIncompleteUploads()
    return d

  def send_GetIncompleteUploads(self):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('GetIncompleteUploads', TMessageType.CALL, self._seqid)
    args = GetIncompleteUploads_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_GetIncompleteUploads(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = GetIncompleteUploads_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "GetIncompleteUploads failed: unknown result"))

  def BeginUpload(self, ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_BeginUpload(ArchiveID)
    return d

  def send_BeginUpload(self, ArchiveID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('BeginUpload', TMessageType.CALL, self._seqid)
    args = BeginUpload_args()
    args.ArchiveID = ArchiveID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_BeginUpload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = BeginUpload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def ResumeUpload(self, ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_ResumeUpload(ArchiveID)
    return d

  def send_ResumeUpload(self, ArchiveID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('ResumeUpload', TMessageType.CALL, self._seqid)
    args = ResumeUpload_args()
    args.ArchiveID = ArchiveID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_ResumeUpload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = ResumeUpload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def QueryArchiveStatus(self, ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_QueryArchiveStatus(ArchiveID)
    return d

  def send_QueryArchiveStatus(self, ArchiveID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('QueryArchiveStatus', TMessageType.CALL, self._seqid)
    args = QueryArchiveStatus_args()
    args.ArchiveID = ArchiveID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_QueryArchiveStatus(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = QueryArchiveStatus_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "QueryArchiveStatus failed: unknown result"))

  def PauseUpload(self, ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_PauseUpload(ArchiveID)
    return d

  def send_PauseUpload(self, ArchiveID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('PauseUpload', TMessageType.CALL, self._seqid)
    args = PauseUpload_args()
    args.ArchiveID = ArchiveID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_PauseUpload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = PauseUpload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def CancelUpload(self, ArchiveID):
    """
    Parameters:
     - ArchiveID
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_CancelUpload(ArchiveID)
    return d

  def send_CancelUpload(self, ArchiveID):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('CancelUpload', TMessageType.CALL, self._seqid)
    args = CancelUpload_args()
    args.ArchiveID = ArchiveID
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_CancelUpload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = CancelUpload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def getCertificates(self):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_getCertificates()
    return d

  def send_getCertificates(self):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getCertificates', TMessageType.CALL, self._seqid)
    args = getCertificates_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getCertificates(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = getCertificates_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "getCertificates failed: unknown result"))

  def GetCertificateFolder(self):
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_GetCertificateFolder()
    return d

  def send_GetCertificateFolder(self):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('GetCertificateFolder', TMessageType.CALL, self._seqid)
    args = GetCertificateFolder_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_GetCertificateFolder(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = GetCertificateFolder_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "GetCertificateFolder failed: unknown result"))

  def SetCertificateFolder(self, path):
    """
    Parameters:
     - path
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_SetCertificateFolder(path)
    return d

  def send_SetCertificateFolder(self, path):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('SetCertificateFolder', TMessageType.CALL, self._seqid)
    args = SetCertificateFolder_args()
    args.path = path
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_SetCertificateFolder(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = SetCertificateFolder_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def Export(self, certificateID, format):
    """
    Parameters:
     - certificateID
     - format
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_Export(certificateID, format)
    return d

  def send_Export(self, certificateID, format):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('Export', TMessageType.CALL, self._seqid)
    args = Export_args()
    args.certificateID = certificateID
    args.format = format
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_Export(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = Export_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "Export failed: unknown result"))

  def Decrypt(self, archivePath, key, destinationPath):
    """
    Parameters:
     - archivePath
     - key
     - destinationPath
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_Decrypt(archivePath, key, destinationPath)
    return d

  def send_Decrypt(self, archivePath, key, destinationPath):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('Decrypt', TMessageType.CALL, self._seqid)
    args = Decrypt_args()
    args.archivePath = archivePath
    args.key = key
    args.destinationPath = destinationPath
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_Decrypt(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = Decrypt_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)


class Processor(TProcessor):
  implements(Iface)

  def __init__(self, handler):
    self._handler = Iface(handler)
    self._processMap = {}
    self._processMap["PingCLI"] = Processor.process_PingCLI
    self._processMap["LoginUser"] = Processor.process_LoginUser
    self._processMap["Logout"] = Processor.process_Logout
    self._processMap["GetCapsules"] = Processor.process_GetCapsules
    self._processMap["UploadFileGUI"] = Processor.process_UploadFileGUI
    self._processMap["GetIncompleteUploads"] = Processor.process_GetIncompleteUploads
    self._processMap["BeginUpload"] = Processor.process_BeginUpload
    self._processMap["ResumeUpload"] = Processor.process_ResumeUpload
    self._processMap["QueryArchiveStatus"] = Processor.process_QueryArchiveStatus
    self._processMap["PauseUpload"] = Processor.process_PauseUpload
    self._processMap["CancelUpload"] = Processor.process_CancelUpload
    self._processMap["getCertificates"] = Processor.process_getCertificates
    self._processMap["GetCertificateFolder"] = Processor.process_GetCertificateFolder
    self._processMap["SetCertificateFolder"] = Processor.process_SetCertificateFolder
    self._processMap["Export"] = Processor.process_Export
    self._processMap["Decrypt"] = Processor.process_Decrypt

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_PingCLI(self, seqid, iprot, oprot):
    args = PingCLI_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PingCLI_result()
    d = defer.maybeDeferred(self._handler.PingCLI, )
    d.addCallback(self.write_results_success_PingCLI, result, seqid, oprot)
    return d

  def write_results_success_PingCLI(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("PingCLI", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_LoginUser(self, seqid, iprot, oprot):
    args = LoginUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = LoginUser_result()
    d = defer.maybeDeferred(self._handler.LoginUser, args.username, args.Pass, args.Remember)
    d.addCallback(self.write_results_success_LoginUser, result, seqid, oprot)
    d.addErrback(self.write_results_exception_LoginUser, result, seqid, oprot)
    return d

  def write_results_success_LoginUser(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("LoginUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_LoginUser(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation, error:
      result.error = error
    oprot.writeMessageBegin("LoginUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_Logout(self, seqid, iprot, oprot):
    args = Logout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Logout_result()
    d = defer.maybeDeferred(self._handler.Logout, )
    d.addCallback(self.write_results_success_Logout, result, seqid, oprot)
    d.addErrback(self.write_results_exception_Logout, result, seqid, oprot)
    return d

  def write_results_success_Logout(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("Logout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_Logout(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation, error:
      result.error = error
    oprot.writeMessageBegin("Logout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCapsules(self, seqid, iprot, oprot):
    args = GetCapsules_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCapsules_result()
    d = defer.maybeDeferred(self._handler.GetCapsules, )
    d.addCallback(self.write_results_success_GetCapsules, result, seqid, oprot)
    d.addErrback(self.write_results_exception_GetCapsules, result, seqid, oprot)
    return d

  def write_results_success_GetCapsules(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("GetCapsules", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_GetCapsules(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation, error:
      result.error = error
    oprot.writeMessageBegin("GetCapsules", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_UploadFileGUI(self, seqid, iprot, oprot):
    args = UploadFileGUI_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = UploadFileGUI_result()
    d = defer.maybeDeferred(self._handler.UploadFileGUI, args.filePaths, args.capsuleID, args.title, args.description)
    d.addCallback(self.write_results_success_UploadFileGUI, result, seqid, oprot)
    d.addErrback(self.write_results_exception_UploadFileGUI, result, seqid, oprot)
    return d

  def write_results_success_UploadFileGUI(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("UploadFileGUI", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_UploadFileGUI(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except InvalidOperation, error:
      result.error = error
    oprot.writeMessageBegin("UploadFileGUI", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetIncompleteUploads(self, seqid, iprot, oprot):
    args = GetIncompleteUploads_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetIncompleteUploads_result()
    d = defer.maybeDeferred(self._handler.GetIncompleteUploads, )
    d.addCallback(self.write_results_success_GetIncompleteUploads, result, seqid, oprot)
    return d

  def write_results_success_GetIncompleteUploads(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("GetIncompleteUploads", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_BeginUpload(self, seqid, iprot, oprot):
    args = BeginUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = BeginUpload_result()
    d = defer.maybeDeferred(self._handler.BeginUpload, args.ArchiveID)
    d.addCallback(self.write_results_success_BeginUpload, result, seqid, oprot)
    return d

  def write_results_success_BeginUpload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("BeginUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ResumeUpload(self, seqid, iprot, oprot):
    args = ResumeUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ResumeUpload_result()
    d = defer.maybeDeferred(self._handler.ResumeUpload, args.ArchiveID)
    d.addCallback(self.write_results_success_ResumeUpload, result, seqid, oprot)
    return d

  def write_results_success_ResumeUpload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("ResumeUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_QueryArchiveStatus(self, seqid, iprot, oprot):
    args = QueryArchiveStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = QueryArchiveStatus_result()
    d = defer.maybeDeferred(self._handler.QueryArchiveStatus, args.ArchiveID)
    d.addCallback(self.write_results_success_QueryArchiveStatus, result, seqid, oprot)
    return d

  def write_results_success_QueryArchiveStatus(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("QueryArchiveStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_PauseUpload(self, seqid, iprot, oprot):
    args = PauseUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PauseUpload_result()
    d = defer.maybeDeferred(self._handler.PauseUpload, args.ArchiveID)
    d.addCallback(self.write_results_success_PauseUpload, result, seqid, oprot)
    return d

  def write_results_success_PauseUpload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("PauseUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CancelUpload(self, seqid, iprot, oprot):
    args = CancelUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CancelUpload_result()
    d = defer.maybeDeferred(self._handler.CancelUpload, args.ArchiveID)
    d.addCallback(self.write_results_success_CancelUpload, result, seqid, oprot)
    return d

  def write_results_success_CancelUpload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("CancelUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCertificates(self, seqid, iprot, oprot):
    args = getCertificates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCertificates_result()
    d = defer.maybeDeferred(self._handler.getCertificates, )
    d.addCallback(self.write_results_success_getCertificates, result, seqid, oprot)
    return d

  def write_results_success_getCertificates(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("getCertificates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetCertificateFolder(self, seqid, iprot, oprot):
    args = GetCertificateFolder_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetCertificateFolder_result()
    d = defer.maybeDeferred(self._handler.GetCertificateFolder, )
    d.addCallback(self.write_results_success_GetCertificateFolder, result, seqid, oprot)
    return d

  def write_results_success_GetCertificateFolder(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("GetCertificateFolder", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetCertificateFolder(self, seqid, iprot, oprot):
    args = SetCertificateFolder_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetCertificateFolder_result()
    d = defer.maybeDeferred(self._handler.SetCertificateFolder, args.path)
    d.addCallback(self.write_results_success_SetCertificateFolder, result, seqid, oprot)
    return d

  def write_results_success_SetCertificateFolder(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("SetCertificateFolder", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_Export(self, seqid, iprot, oprot):
    args = Export_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Export_result()
    d = defer.maybeDeferred(self._handler.Export, args.certificateID, args.format)
    d.addCallback(self.write_results_success_Export, result, seqid, oprot)
    return d

  def write_results_success_Export(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("Export", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_Decrypt(self, seqid, iprot, oprot):
    args = Decrypt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Decrypt_result()
    d = defer.maybeDeferred(self._handler.Decrypt, args.archivePath, args.key, args.destinationPath)
    d.addCallback(self.write_results_success_Decrypt, result, seqid, oprot)
    return d

  def write_results_success_Decrypt(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("Decrypt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class PingCLI_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PingCLI_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PingCLI_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PingCLI_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LoginUser_args(object):
  """
  Attributes:
   - username
   - Pass
   - Remember
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
    (2, TType.STRING, 'Pass', None, None, ), # 2
    (3, TType.BOOL, 'Remember', None, None, ), # 3
  )

  def __init__(self, username=None, Pass=None, Remember=None,):
    self.username = username
    self.Pass = Pass
    self.Remember = Remember

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.Pass = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.Remember = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LoginUser_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.Pass is not None:
      oprot.writeFieldBegin('Pass', TType.STRING, 2)
      oprot.writeString(self.Pass)
      oprot.writeFieldEnd()
    if self.Remember is not None:
      oprot.writeFieldBegin('Remember', TType.BOOL, 3)
      oprot.writeBool(self.Remember)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LoginUser_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LoginUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Logout_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Logout_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Logout_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Logout_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCapsules_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCapsules_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCapsules_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Capsule, Capsule.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = Capsule()
            _elem5.read(iprot)
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCapsules_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter6 in self.success:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UploadFileGUI_args(object):
  """
  Attributes:
   - filePaths
   - capsuleID
   - title
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'filePaths', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'capsuleID', None, None, ), # 2
    (3, TType.STRING, 'title', None, None, ), # 3
    (4, TType.STRING, 'description', None, None, ), # 4
  )

  def __init__(self, filePaths=None, capsuleID=None, title=None, description=None,):
    self.filePaths = filePaths
    self.capsuleID = capsuleID
    self.title = title
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.filePaths = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.filePaths.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.capsuleID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UploadFileGUI_args')
    if self.filePaths is not None:
      oprot.writeFieldBegin('filePaths', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.filePaths))
      for iter13 in self.filePaths:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.capsuleID is not None:
      oprot.writeFieldBegin('capsuleID', TType.STRING, 2)
      oprot.writeString(self.capsuleID)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 3)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 4)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UploadFileGUI_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Archive, Archive.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (InvalidOperation, InvalidOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Archive()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = InvalidOperation()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UploadFileGUI_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetIncompleteUploads_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetIncompleteUploads_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetIncompleteUploads_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Archive, Archive.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = Archive()
            _elem19.read(iprot)
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetIncompleteUploads_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter20 in self.success:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BeginUpload_args(object):
  """
  Attributes:
   - ArchiveID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveID', None, None, ), # 1
  )

  def __init__(self, ArchiveID=None,):
    self.ArchiveID = ArchiveID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BeginUpload_args')
    if self.ArchiveID is not None:
      oprot.writeFieldBegin('ArchiveID', TType.STRING, 1)
      oprot.writeString(self.ArchiveID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BeginUpload_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BeginUpload_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResumeUpload_args(object):
  """
  Attributes:
   - ArchiveID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveID', None, None, ), # 1
  )

  def __init__(self, ArchiveID=None,):
    self.ArchiveID = ArchiveID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResumeUpload_args')
    if self.ArchiveID is not None:
      oprot.writeFieldBegin('ArchiveID', TType.STRING, 1)
      oprot.writeString(self.ArchiveID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResumeUpload_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResumeUpload_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryArchiveStatus_args(object):
  """
  Attributes:
   - ArchiveID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveID', None, None, ), # 1
  )

  def __init__(self, ArchiveID=None,):
    self.ArchiveID = ArchiveID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryArchiveStatus_args')
    if self.ArchiveID is not None:
      oprot.writeFieldBegin('ArchiveID', TType.STRING, 1)
      oprot.writeString(self.ArchiveID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryArchiveStatus_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TransferStatus, TransferStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TransferStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryArchiveStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PauseUpload_args(object):
  """
  Attributes:
   - ArchiveID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveID', None, None, ), # 1
  )

  def __init__(self, ArchiveID=None,):
    self.ArchiveID = ArchiveID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PauseUpload_args')
    if self.ArchiveID is not None:
      oprot.writeFieldBegin('ArchiveID', TType.STRING, 1)
      oprot.writeString(self.ArchiveID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PauseUpload_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PauseUpload_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CancelUpload_args(object):
  """
  Attributes:
   - ArchiveID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ArchiveID', None, None, ), # 1
  )

  def __init__(self, ArchiveID=None,):
    self.ArchiveID = ArchiveID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ArchiveID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CancelUpload_args')
    if self.ArchiveID is not None:
      oprot.writeFieldBegin('ArchiveID', TType.STRING, 1)
      oprot.writeString(self.ArchiveID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CancelUpload_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CancelUpload_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCertificates_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCertificates_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCertificates_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Certificate, Certificate.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = Certificate()
            _elem26.read(iprot)
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCertificates_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter27 in self.success:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCertificateFolder_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCertificateFolder_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetCertificateFolder_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetCertificateFolder_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetCertificateFolder_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetCertificateFolder_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetCertificateFolder_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetCertificateFolder_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Export_args(object):
  """
  Attributes:
   - certificateID
   - format
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'certificateID', None, None, ), # 1
    (2, TType.STRING, 'format', None, None, ), # 2
  )

  def __init__(self, certificateID=None, format=None,):
    self.certificateID = certificateID
    self.format = format

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.certificateID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.format = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Export_args')
    if self.certificateID is not None:
      oprot.writeFieldBegin('certificateID', TType.STRING, 1)
      oprot.writeString(self.certificateID)
      oprot.writeFieldEnd()
    if self.format is not None:
      oprot.writeFieldBegin('format', TType.STRING, 2)
      oprot.writeString(self.format)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Export_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Export_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Decrypt_args(object):
  """
  Attributes:
   - archivePath
   - key
   - destinationPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'archivePath', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'destinationPath', None, None, ), # 3
  )

  def __init__(self, archivePath=None, key=None, destinationPath=None,):
    self.archivePath = archivePath
    self.key = key
    self.destinationPath = destinationPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.archivePath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.destinationPath = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Decrypt_args')
    if self.archivePath is not None:
      oprot.writeFieldBegin('archivePath', TType.STRING, 1)
      oprot.writeString(self.archivePath)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.destinationPath is not None:
      oprot.writeFieldBegin('destinationPath', TType.STRING, 3)
      oprot.writeString(self.destinationPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Decrypt_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Decrypt_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
